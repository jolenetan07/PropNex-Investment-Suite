'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var rxjs = require('rxjs');

function checkReady() {
    if (typeof process === 'undefined') {
        var win_1 = typeof window !== 'undefined' ? window : {};
        var DEVICE_READY_TIMEOUT_1 = 5000;
        // To help developers using cordova, we listen for the device ready event and
        // log an error if it didn't fire in a reasonable amount of time. Generally,
        // when this happens, developers should remove and reinstall plugins, since
        // an inconsistent plugin is often the culprit.
        var before_1 = Date.now();
        var didFireReady_1 = false;
        win_1.document.addEventListener('deviceready', function () {
            console.log("Ionic Native: deviceready event fired after " + (Date.now() - before_1) + " ms");
            didFireReady_1 = true;
        });
        setTimeout(function () {
            if (!didFireReady_1 && win_1.cordova) {
                console.warn("Ionic Native: deviceready did not fire within " + DEVICE_READY_TIMEOUT_1 + "ms. This can happen when plugins are in an inconsistent state. Try removing plugins from plugins/ and reinstalling them.");
            }
        }, DEVICE_READY_TIMEOUT_1);
    }
}

var ERR_CORDOVA_NOT_AVAILABLE = { error: 'cordova_not_available' };
var ERR_PLUGIN_NOT_INSTALLED = { error: 'plugin_not_installed' };
function getPromise(callback) {
    var tryNativePromise = function () {
        if (Promise) {
            return new Promise(function (resolve, reject) {
                callback(resolve, reject);
            });
        }
        else {
            console.error('No Promise support or polyfill found. To enable Ionic Native support, please add the es6-promise polyfill before this script, or run with a library like Angular or on a recent browser.');
        }
    };
    if (typeof window !== 'undefined' && window.angular) {
        var doc = window.document;
        var injector = window.angular.element(doc.querySelector('[ng-app]') || doc.body).injector();
        if (injector) {
            var $q = injector.get('$q');
            return $q(function (resolve, reject) {
                callback(resolve, reject);
            });
        }
        console.warn("Angular 1 was detected but $q couldn't be retrieved. This is usually when the app is not bootstrapped on the html or body tag. Falling back to native promises which won't trigger an automatic digest when promises resolve.");
    }
    return tryNativePromise();
}
function wrapPromise(pluginObj, methodName, args, opts) {
    if (opts === void 0) { opts = {}; }
    var pluginResult, rej;
    var p = getPromise(function (resolve, reject) {
        if (opts.destruct) {
            pluginResult = callCordovaPlugin(pluginObj, methodName, args, opts, function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return resolve(args);
            }, function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return reject(args);
            });
        }
        else {
            pluginResult = callCordovaPlugin(pluginObj, methodName, args, opts, resolve, reject);
        }
        rej = reject;
    });
    // Angular throws an error on unhandled rejection, but in this case we have already printed
    // a warning that Cordova is undefined or the plugin is uninstalled, so there is no reason
    // to error
    if (pluginResult && pluginResult.error) {
        p.catch(function () { });
        typeof rej === 'function' && rej(pluginResult.error);
    }
    return p;
}
function wrapOtherPromise(pluginObj, methodName, args, opts) {
    if (opts === void 0) { opts = {}; }
    return getPromise(function (resolve, reject) {
        var pluginResult = callCordovaPlugin(pluginObj, methodName, args, opts);
        if (pluginResult) {
            if (pluginResult.error) {
                reject(pluginResult.error);
            }
            else if (pluginResult.then) {
                pluginResult.then(resolve).catch(reject);
            }
        }
        else {
            reject({ error: 'unexpected_error' });
        }
    });
}
function wrapObservable(pluginObj, methodName, args, opts) {
    if (opts === void 0) { opts = {}; }
    return new rxjs.Observable(function (observer) {
        var pluginResult;
        if (opts.destruct) {
            pluginResult = callCordovaPlugin(pluginObj, methodName, args, opts, function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return observer.next(args);
            }, function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return observer.error(args);
            });
        }
        else {
            pluginResult = callCordovaPlugin(pluginObj, methodName, args, opts, observer.next.bind(observer), observer.error.bind(observer));
        }
        if (pluginResult && pluginResult.error) {
            observer.error(pluginResult.error);
            observer.complete();
        }
        return function () {
            try {
                if (opts.clearFunction) {
                    if (opts.clearWithArgs) {
                        return callCordovaPlugin(pluginObj, opts.clearFunction, args, opts, observer.next.bind(observer), observer.error.bind(observer));
                    }
                    return callCordovaPlugin(pluginObj, opts.clearFunction, []);
                }
            }
            catch (e) {
                console.warn('Unable to clear the previous observable watch for', pluginObj.constructor.getPluginName(), methodName);
                console.warn(e);
            }
        };
    });
}
/**
 * Wrap the event with an observable
 * @private
 * @param event event name
 * @param element The element to attach the event listener to
 * @returns {Observable}
 */
function wrapEventObservable(event, element) {
    element =
        typeof window !== 'undefined' && element
            ? get$1(window, element)
            : element || (typeof window !== 'undefined' ? window : {});
    return rxjs.fromEvent(element, event);
}
function checkAvailability(plugin, methodName, pluginName) {
    var pluginRef, pluginInstance, pluginPackage;
    if (typeof plugin === 'string') {
        pluginRef = plugin;
    }
    else {
        pluginRef = plugin.constructor.getPluginRef();
        pluginName = plugin.constructor.getPluginName();
        pluginPackage = plugin.constructor.getPluginInstallName();
    }
    pluginInstance = getPlugin(pluginRef);
    if (!pluginInstance || (!!methodName && typeof pluginInstance[methodName] === 'undefined')) {
        if (typeof window === 'undefined' || !window.cordova) {
            cordovaWarn(pluginName, methodName);
            return ERR_CORDOVA_NOT_AVAILABLE;
        }
        pluginWarn(pluginName, pluginPackage, methodName);
        return ERR_PLUGIN_NOT_INSTALLED;
    }
    return true;
}
/**
 * Checks if _objectInstance exists and has the method/property
 * @private
 */
function instanceAvailability(pluginObj, methodName) {
    return pluginObj._objectInstance && (!methodName || typeof pluginObj._objectInstance[methodName] !== 'undefined');
}
function setIndex(args, opts, resolve, reject) {
    if (opts === void 0) { opts = {}; }
    // ignore resolve and reject in case sync
    if (opts.sync) {
        return args;
    }
    // If the plugin method expects myMethod(success, err, options)
    if (opts.callbackOrder === 'reverse') {
        // Get those arguments in the order [resolve, reject, ...restOfArgs]
        args.unshift(reject);
        args.unshift(resolve);
    }
    else if (opts.callbackStyle === 'node') {
        args.push(function (err, result) {
            if (err) {
                reject(err);
            }
            else {
                resolve(result);
            }
        });
    }
    else if (opts.callbackStyle === 'object' && opts.successName && opts.errorName) {
        var obj = {};
        obj[opts.successName] = resolve;
        obj[opts.errorName] = reject;
        args.push(obj);
    }
    else if (typeof opts.successIndex !== 'undefined' || typeof opts.errorIndex !== 'undefined') {
        var setSuccessIndex = function () {
            // If we've specified a success/error index
            if (opts.successIndex > args.length) {
                args[opts.successIndex] = resolve;
            }
            else {
                args.splice(opts.successIndex, 0, resolve);
            }
        };
        var setErrorIndex = function () {
            // We don't want that the reject cb gets spliced into the position of an optional argument that has not been
            // defined and thus causing non expected behavior.
            if (opts.errorIndex > args.length) {
                args[opts.errorIndex] = reject; // insert the reject fn at the correct specific index
            }
            else {
                args.splice(opts.errorIndex, 0, reject); // otherwise just splice it into the array
            }
        };
        if (opts.successIndex > opts.errorIndex) {
            setErrorIndex();
            setSuccessIndex();
        }
        else {
            setSuccessIndex();
            setErrorIndex();
        }
    }
    else {
        // Otherwise, let's tack them on to the end of the argument list
        // which is 90% of cases
        args.push(resolve);
        args.push(reject);
    }
    return args;
}
function callCordovaPlugin(pluginObj, methodName, args, opts, resolve, reject) {
    if (opts === void 0) { opts = {}; }
    // Try to figure out where the success/error callbacks need to be bound
    // to our promise resolve/reject handlers.
    args = setIndex(args, opts, resolve, reject);
    var availabilityCheck = checkAvailability(pluginObj, methodName);
    if (availabilityCheck === true) {
        var pluginInstance = getPlugin(pluginObj.constructor.getPluginRef());
        return pluginInstance[methodName].apply(pluginInstance, args);
    }
    else {
        return availabilityCheck;
    }
}
function callInstance(pluginObj, methodName, args, opts, resolve, reject) {
    if (opts === void 0) { opts = {}; }
    args = setIndex(args, opts, resolve, reject);
    if (instanceAvailability(pluginObj, methodName)) {
        return pluginObj._objectInstance[methodName].apply(pluginObj._objectInstance, args);
    }
}
function getPlugin(pluginRef) {
    if (typeof window !== 'undefined') {
        return get$1(window, pluginRef);
    }
    return null;
}
function get$1(element, path) {
    var paths = path.split('.');
    var obj = element;
    for (var i = 0; i < paths.length; i++) {
        if (!obj) {
            return null;
        }
        obj = obj[paths[i]];
    }
    return obj;
}
function pluginWarn(pluginName, plugin, method) {
    if (method) {
        console.warn('Native: tried calling ' + pluginName + '.' + method + ', but the ' + pluginName + ' plugin is not installed.');
    }
    else {
        console.warn("Native: tried accessing the " + pluginName + " plugin but it's not installed.");
    }
    if (plugin) {
        console.warn("Install the " + pluginName + " plugin: 'ionic cordova plugin add " + plugin + "'");
    }
}
/**
 * @private
 * @param pluginName
 * @param method
 */
function cordovaWarn(pluginName, method) {
    if (typeof process === 'undefined') {
        if (method) {
            console.warn('Native: tried calling ' +
                pluginName +
                '.' +
                method +
                ', but Cordova is not available. Make sure to include cordova.js or run in a device/simulator');
        }
        else {
            console.warn('Native: tried accessing the ' +
                pluginName +
                ' plugin but Cordova is not available. Make sure to include cordova.js or run in a device/simulator');
        }
    }
}
/**
 * @private
 */
var wrap = function (pluginObj, methodName, opts) {
    if (opts === void 0) { opts = {}; }
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (opts.sync) {
            // Sync doesn't wrap the plugin with a promise or observable, it returns the result as-is
            return callCordovaPlugin(pluginObj, methodName, args, opts);
        }
        else if (opts.observable) {
            return wrapObservable(pluginObj, methodName, args, opts);
        }
        else if (opts.eventObservable && opts.event) {
            return wrapEventObservable(opts.event, opts.element);
        }
        else if (opts.otherPromise) {
            return wrapOtherPromise(pluginObj, methodName, args, opts);
        }
        else {
            return wrapPromise(pluginObj, methodName, args, opts);
        }
    };
};
/**
 * @private
 */
function wrapInstance(pluginObj, methodName, opts) {
    if (opts === void 0) { opts = {}; }
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (opts.sync) {
            return callInstance(pluginObj, methodName, args, opts);
        }
        else if (opts.observable) {
            return new rxjs.Observable(function (observer) {
                var pluginResult;
                if (opts.destruct) {
                    pluginResult = callInstance(pluginObj, methodName, args, opts, function () {
                        var args = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            args[_i] = arguments[_i];
                        }
                        return observer.next(args);
                    }, function () {
                        var args = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            args[_i] = arguments[_i];
                        }
                        return observer.error(args);
                    });
                }
                else {
                    pluginResult = callInstance(pluginObj, methodName, args, opts, observer.next.bind(observer), observer.error.bind(observer));
                }
                if (pluginResult && pluginResult.error) {
                    observer.error(pluginResult.error);
                }
                return function () {
                    try {
                        if (opts.clearWithArgs) {
                            return callInstance(pluginObj, opts.clearFunction, args, opts, observer.next.bind(observer), observer.error.bind(observer));
                        }
                        return callInstance(pluginObj, opts.clearFunction, []);
                    }
                    catch (e) {
                        console.warn('Unable to clear the previous observable watch for', pluginObj.constructor.getPluginName(), methodName);
                        console.warn(e);
                    }
                };
            });
        }
        else if (opts.otherPromise) {
            return getPromise(function (resolve, reject) {
                var result;
                if (opts.destruct) {
                    result = callInstance(pluginObj, methodName, args, opts, function () {
                        var args = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            args[_i] = arguments[_i];
                        }
                        return resolve(args);
                    }, function () {
                        var args = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            args[_i] = arguments[_i];
                        }
                        return reject(args);
                    });
                }
                else {
                    result = callInstance(pluginObj, methodName, args, opts, resolve, reject);
                }
                if (result && result.then) {
                    result.then(resolve, reject);
                }
                else {
                    reject();
                }
            });
        }
        else {
            var pluginResult_1, rej_1;
            var p = getPromise(function (resolve, reject) {
                if (opts.destruct) {
                    pluginResult_1 = callInstance(pluginObj, methodName, args, opts, function () {
                        var args = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            args[_i] = arguments[_i];
                        }
                        return resolve(args);
                    }, function () {
                        var args = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            args[_i] = arguments[_i];
                        }
                        return reject(args);
                    });
                }
                else {
                    pluginResult_1 = callInstance(pluginObj, methodName, args, opts, resolve, reject);
                }
                rej_1 = reject;
            });
            // Angular throws an error on unhandled rejection, but in this case we have already printed
            // a warning that Cordova is undefined or the plugin is uninstalled, so there is no reason
            // to error
            if (pluginResult_1 && pluginResult_1.error) {
                p.catch(function () { });
                typeof rej_1 === 'function' && rej_1(pluginResult_1.error);
            }
            return p;
        }
    };
}

/**
 * @private
 */
function get(element, path) {
    var paths = path.split('.');
    var obj = element;
    for (var i = 0; i < paths.length; i++) {
        if (!obj) {
            return null;
        }
        obj = obj[paths[i]];
    }
    return obj;
}

var IonicNativePlugin = /** @class */ (function () {
    function IonicNativePlugin() {
    }
    /**
     * Returns a boolean that indicates whether the plugin is installed
     * @return {boolean}
     */
    IonicNativePlugin.installed = function () {
        var isAvailable = checkAvailability(this.pluginRef) === true;
        return isAvailable;
    };
    /**
     * Returns the original plugin object
     */
    IonicNativePlugin.getPlugin = function () {
        if (typeof window !== 'undefined') {
            return get(window, this.pluginRef);
        }
        return null;
    };
    /**
     * Returns the plugin's name
     */
    IonicNativePlugin.getPluginName = function () {
        var pluginName = this.pluginName;
        return pluginName;
    };
    /**
     * Returns the plugin's reference
     */
    IonicNativePlugin.getPluginRef = function () {
        var pluginRef = this.pluginRef;
        return pluginRef;
    };
    /**
     * Returns the plugin's install name
     */
    IonicNativePlugin.getPluginInstallName = function () {
        var plugin = this.plugin;
        return plugin;
    };
    /**
     * Returns the plugin's supported platforms
     */
    IonicNativePlugin.getSupportedPlatforms = function () {
        var platform = this.platforms;
        return platform;
    };
    IonicNativePlugin.pluginName = '';
    IonicNativePlugin.pluginRef = '';
    IonicNativePlugin.plugin = '';
    IonicNativePlugin.repo = '';
    IonicNativePlugin.platforms = [];
    IonicNativePlugin.install = '';
    return IonicNativePlugin;
}());

function cordova(pluginObj, methodName, config, args) {
    return wrap(pluginObj, methodName, config).apply(this, args);
}

function overrideFunction(pluginObj, methodName) {
    return new rxjs.Observable(function (observer) {
        var availabilityCheck = checkAvailability(pluginObj, methodName);
        if (availabilityCheck === true) {
            var pluginInstance_1 = getPlugin(pluginObj.constructor.getPluginRef());
            pluginInstance_1[methodName] = observer.next.bind(observer);
            return function () { return (pluginInstance_1[methodName] = function () { }); };
        }
        else {
            observer.error(availabilityCheck);
            observer.complete();
        }
    });
}
function cordovaFunctionOverride(pluginObj, methodName, args) {
    return overrideFunction(pluginObj, methodName);
}

function cordovaInstance(pluginObj, methodName, config, args) {
    args = Array.from(args);
    return wrapInstance(pluginObj, methodName, config).apply(this, args);
}

function cordovaPropertyGet(pluginObj, key) {
    if (checkAvailability(pluginObj, key) === true) {
        return getPlugin(pluginObj.constructor.getPluginRef())[key];
    }
    return null;
}
function cordovaPropertySet(pluginObj, key, value) {
    if (checkAvailability(pluginObj, key) === true) {
        getPlugin(pluginObj.constructor.getPluginRef())[key] = value;
    }
}

function instancePropertyGet(pluginObj, key) {
    if (pluginObj._objectInstance && pluginObj._objectInstance[key]) {
        return pluginObj._objectInstance[key];
    }
    return null;
}
function instancePropertySet(pluginObj, key, value) {
    if (pluginObj._objectInstance) {
        pluginObj._objectInstance[key] = value;
    }
}

checkReady();

exports.IonicNativePlugin = IonicNativePlugin;
exports.checkAvailability = checkAvailability;
exports.cordova = cordova;
exports.cordovaFunctionOverride = cordovaFunctionOverride;
exports.cordovaInstance = cordovaInstance;
exports.cordovaPropertyGet = cordovaPropertyGet;
exports.cordovaPropertySet = cordovaPropertySet;
exports.getPromise = getPromise;
exports.instanceAvailability = instanceAvailability;
exports.instancePropertyGet = instancePropertyGet;
exports.instancePropertySet = instancePropertySet;
exports.wrap = wrap;

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnVuZGxlLmpzIiwic291cmNlcyI6WyJidW5kbGUuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuXHJcbnZhciByeGpzID0gcmVxdWlyZSgncnhqcycpO1xyXG5cclxuZnVuY3Rpb24gY2hlY2tSZWFkeSgpIHtcclxuICAgIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICB2YXIgd2luXzEgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHt9O1xyXG4gICAgICAgIHZhciBERVZJQ0VfUkVBRFlfVElNRU9VVF8xID0gNTAwMDtcclxuICAgICAgICAvLyBUbyBoZWxwIGRldmVsb3BlcnMgdXNpbmcgY29yZG92YSwgd2UgbGlzdGVuIGZvciB0aGUgZGV2aWNlIHJlYWR5IGV2ZW50IGFuZFxyXG4gICAgICAgIC8vIGxvZyBhbiBlcnJvciBpZiBpdCBkaWRuJ3QgZmlyZSBpbiBhIHJlYXNvbmFibGUgYW1vdW50IG9mIHRpbWUuIEdlbmVyYWxseSxcclxuICAgICAgICAvLyB3aGVuIHRoaXMgaGFwcGVucywgZGV2ZWxvcGVycyBzaG91bGQgcmVtb3ZlIGFuZCByZWluc3RhbGwgcGx1Z2lucywgc2luY2VcclxuICAgICAgICAvLyBhbiBpbmNvbnNpc3RlbnQgcGx1Z2luIGlzIG9mdGVuIHRoZSBjdWxwcml0LlxyXG4gICAgICAgIHZhciBiZWZvcmVfMSA9IERhdGUubm93KCk7XHJcbiAgICAgICAgdmFyIGRpZEZpcmVSZWFkeV8xID0gZmFsc2U7XHJcbiAgICAgICAgd2luXzEuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZGV2aWNlcmVhZHknLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiSW9uaWMgTmF0aXZlOiBkZXZpY2VyZWFkeSBldmVudCBmaXJlZCBhZnRlciBcIiArIChEYXRlLm5vdygpIC0gYmVmb3JlXzEpICsgXCIgbXNcIik7XHJcbiAgICAgICAgICAgIGRpZEZpcmVSZWFkeV8xID0gdHJ1ZTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKCFkaWRGaXJlUmVhZHlfMSAmJiB3aW5fMS5jb3Jkb3ZhKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJJb25pYyBOYXRpdmU6IGRldmljZXJlYWR5IGRpZCBub3QgZmlyZSB3aXRoaW4gXCIgKyBERVZJQ0VfUkVBRFlfVElNRU9VVF8xICsgXCJtcy4gVGhpcyBjYW4gaGFwcGVuIHdoZW4gcGx1Z2lucyBhcmUgaW4gYW4gaW5jb25zaXN0ZW50IHN0YXRlLiBUcnkgcmVtb3ZpbmcgcGx1Z2lucyBmcm9tIHBsdWdpbnMvIGFuZCByZWluc3RhbGxpbmcgdGhlbS5cIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCBERVZJQ0VfUkVBRFlfVElNRU9VVF8xKTtcclxuICAgIH1cclxufVxyXG5cclxudmFyIEVSUl9DT1JET1ZBX05PVF9BVkFJTEFCTEUgPSB7IGVycm9yOiAnY29yZG92YV9ub3RfYXZhaWxhYmxlJyB9O1xyXG52YXIgRVJSX1BMVUdJTl9OT1RfSU5TVEFMTEVEID0geyBlcnJvcjogJ3BsdWdpbl9ub3RfaW5zdGFsbGVkJyB9O1xyXG5mdW5jdGlvbiBnZXRQcm9taXNlKGNhbGxiYWNrKSB7XHJcbiAgICB2YXIgdHJ5TmF0aXZlUHJvbWlzZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoUHJvbWlzZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2socmVzb2x2ZSwgcmVqZWN0KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdObyBQcm9taXNlIHN1cHBvcnQgb3IgcG9seWZpbGwgZm91bmQuIFRvIGVuYWJsZSBJb25pYyBOYXRpdmUgc3VwcG9ydCwgcGxlYXNlIGFkZCB0aGUgZXM2LXByb21pc2UgcG9seWZpbGwgYmVmb3JlIHRoaXMgc2NyaXB0LCBvciBydW4gd2l0aCBhIGxpYnJhcnkgbGlrZSBBbmd1bGFyIG9yIG9uIGEgcmVjZW50IGJyb3dzZXIuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuYW5ndWxhcikge1xyXG4gICAgICAgIHZhciBkb2MgPSB3aW5kb3cuZG9jdW1lbnQ7XHJcbiAgICAgICAgdmFyIGluamVjdG9yID0gd2luZG93LmFuZ3VsYXIuZWxlbWVudChkb2MucXVlcnlTZWxlY3RvcignW25nLWFwcF0nKSB8fCBkb2MuYm9keSkuaW5qZWN0b3IoKTtcclxuICAgICAgICBpZiAoaW5qZWN0b3IpIHtcclxuICAgICAgICAgICAgdmFyICRxID0gaW5qZWN0b3IuZ2V0KCckcScpO1xyXG4gICAgICAgICAgICByZXR1cm4gJHEoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2socmVzb2x2ZSwgcmVqZWN0KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnNvbGUud2FybihcIkFuZ3VsYXIgMSB3YXMgZGV0ZWN0ZWQgYnV0ICRxIGNvdWxkbid0IGJlIHJldHJpZXZlZC4gVGhpcyBpcyB1c3VhbGx5IHdoZW4gdGhlIGFwcCBpcyBub3QgYm9vdHN0cmFwcGVkIG9uIHRoZSBodG1sIG9yIGJvZHkgdGFnLiBGYWxsaW5nIGJhY2sgdG8gbmF0aXZlIHByb21pc2VzIHdoaWNoIHdvbid0IHRyaWdnZXIgYW4gYXV0b21hdGljIGRpZ2VzdCB3aGVuIHByb21pc2VzIHJlc29sdmUuXCIpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRyeU5hdGl2ZVByb21pc2UoKTtcclxufVxyXG5mdW5jdGlvbiB3cmFwUHJvbWlzZShwbHVnaW5PYmosIG1ldGhvZE5hbWUsIGFyZ3MsIG9wdHMpIHtcclxuICAgIGlmIChvcHRzID09PSB2b2lkIDApIHsgb3B0cyA9IHt9OyB9XHJcbiAgICB2YXIgcGx1Z2luUmVzdWx0LCByZWo7XHJcbiAgICB2YXIgcCA9IGdldFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGlmIChvcHRzLmRlc3RydWN0KSB7XHJcbiAgICAgICAgICAgIHBsdWdpblJlc3VsdCA9IGNhbGxDb3Jkb3ZhUGx1Z2luKHBsdWdpbk9iaiwgbWV0aG9kTmFtZSwgYXJncywgb3B0cywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoYXJncyk7XHJcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gW107XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoYXJncyk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcGx1Z2luUmVzdWx0ID0gY2FsbENvcmRvdmFQbHVnaW4ocGx1Z2luT2JqLCBtZXRob2ROYW1lLCBhcmdzLCBvcHRzLCByZXNvbHZlLCByZWplY3QpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZWogPSByZWplY3Q7XHJcbiAgICB9KTtcclxuICAgIC8vIEFuZ3VsYXIgdGhyb3dzIGFuIGVycm9yIG9uIHVuaGFuZGxlZCByZWplY3Rpb24sIGJ1dCBpbiB0aGlzIGNhc2Ugd2UgaGF2ZSBhbHJlYWR5IHByaW50ZWRcclxuICAgIC8vIGEgd2FybmluZyB0aGF0IENvcmRvdmEgaXMgdW5kZWZpbmVkIG9yIHRoZSBwbHVnaW4gaXMgdW5pbnN0YWxsZWQsIHNvIHRoZXJlIGlzIG5vIHJlYXNvblxyXG4gICAgLy8gdG8gZXJyb3JcclxuICAgIGlmIChwbHVnaW5SZXN1bHQgJiYgcGx1Z2luUmVzdWx0LmVycm9yKSB7XHJcbiAgICAgICAgcC5jYXRjaChmdW5jdGlvbiAoKSB7IH0pO1xyXG4gICAgICAgIHR5cGVvZiByZWogPT09ICdmdW5jdGlvbicgJiYgcmVqKHBsdWdpblJlc3VsdC5lcnJvcik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcDtcclxufVxyXG5mdW5jdGlvbiB3cmFwT3RoZXJQcm9taXNlKHBsdWdpbk9iaiwgbWV0aG9kTmFtZSwgYXJncywgb3B0cykge1xyXG4gICAgaWYgKG9wdHMgPT09IHZvaWQgMCkgeyBvcHRzID0ge307IH1cclxuICAgIHJldHVybiBnZXRQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICB2YXIgcGx1Z2luUmVzdWx0ID0gY2FsbENvcmRvdmFQbHVnaW4ocGx1Z2luT2JqLCBtZXRob2ROYW1lLCBhcmdzLCBvcHRzKTtcclxuICAgICAgICBpZiAocGx1Z2luUmVzdWx0KSB7XHJcbiAgICAgICAgICAgIGlmIChwbHVnaW5SZXN1bHQuZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIHJlamVjdChwbHVnaW5SZXN1bHQuZXJyb3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHBsdWdpblJlc3VsdC50aGVuKSB7XHJcbiAgICAgICAgICAgICAgICBwbHVnaW5SZXN1bHQudGhlbihyZXNvbHZlKS5jYXRjaChyZWplY3QpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZWplY3QoeyBlcnJvcjogJ3VuZXhwZWN0ZWRfZXJyb3InIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIHdyYXBPYnNlcnZhYmxlKHBsdWdpbk9iaiwgbWV0aG9kTmFtZSwgYXJncywgb3B0cykge1xyXG4gICAgaWYgKG9wdHMgPT09IHZvaWQgMCkgeyBvcHRzID0ge307IH1cclxuICAgIHJldHVybiBuZXcgcnhqcy5PYnNlcnZhYmxlKGZ1bmN0aW9uIChvYnNlcnZlcikge1xyXG4gICAgICAgIHZhciBwbHVnaW5SZXN1bHQ7XHJcbiAgICAgICAgaWYgKG9wdHMuZGVzdHJ1Y3QpIHtcclxuICAgICAgICAgICAgcGx1Z2luUmVzdWx0ID0gY2FsbENvcmRvdmFQbHVnaW4ocGx1Z2luT2JqLCBtZXRob2ROYW1lLCBhcmdzLCBvcHRzLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JzZXJ2ZXIubmV4dChhcmdzKTtcclxuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9ic2VydmVyLmVycm9yKGFyZ3MpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHBsdWdpblJlc3VsdCA9IGNhbGxDb3Jkb3ZhUGx1Z2luKHBsdWdpbk9iaiwgbWV0aG9kTmFtZSwgYXJncywgb3B0cywgb2JzZXJ2ZXIubmV4dC5iaW5kKG9ic2VydmVyKSwgb2JzZXJ2ZXIuZXJyb3IuYmluZChvYnNlcnZlcikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocGx1Z2luUmVzdWx0ICYmIHBsdWdpblJlc3VsdC5lcnJvcikge1xyXG4gICAgICAgICAgICBvYnNlcnZlci5lcnJvcihwbHVnaW5SZXN1bHQuZXJyb3IpO1xyXG4gICAgICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG9wdHMuY2xlYXJGdW5jdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRzLmNsZWFyV2l0aEFyZ3MpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxDb3Jkb3ZhUGx1Z2luKHBsdWdpbk9iaiwgb3B0cy5jbGVhckZ1bmN0aW9uLCBhcmdzLCBvcHRzLCBvYnNlcnZlci5uZXh0LmJpbmQob2JzZXJ2ZXIpLCBvYnNlcnZlci5lcnJvci5iaW5kKG9ic2VydmVyKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsQ29yZG92YVBsdWdpbihwbHVnaW5PYmosIG9wdHMuY2xlYXJGdW5jdGlvbiwgW10pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1VuYWJsZSB0byBjbGVhciB0aGUgcHJldmlvdXMgb2JzZXJ2YWJsZSB3YXRjaCBmb3InLCBwbHVnaW5PYmouY29uc3RydWN0b3IuZ2V0UGx1Z2luTmFtZSgpLCBtZXRob2ROYW1lKTtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9KTtcclxufVxyXG4vKipcclxuICogV3JhcCB0aGUgZXZlbnQgd2l0aCBhbiBvYnNlcnZhYmxlXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSBldmVudCBldmVudCBuYW1lXHJcbiAqIEBwYXJhbSBlbGVtZW50IFRoZSBlbGVtZW50IHRvIGF0dGFjaCB0aGUgZXZlbnQgbGlzdGVuZXIgdG9cclxuICogQHJldHVybnMge09ic2VydmFibGV9XHJcbiAqL1xyXG5mdW5jdGlvbiB3cmFwRXZlbnRPYnNlcnZhYmxlKGV2ZW50LCBlbGVtZW50KSB7XHJcbiAgICBlbGVtZW50ID1cclxuICAgICAgICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiBlbGVtZW50XHJcbiAgICAgICAgICAgID8gZ2V0JDEod2luZG93LCBlbGVtZW50KVxyXG4gICAgICAgICAgICA6IGVsZW1lbnQgfHwgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDoge30pO1xyXG4gICAgcmV0dXJuIHJ4anMuZnJvbUV2ZW50KGVsZW1lbnQsIGV2ZW50KTtcclxufVxyXG5mdW5jdGlvbiBjaGVja0F2YWlsYWJpbGl0eShwbHVnaW4sIG1ldGhvZE5hbWUsIHBsdWdpbk5hbWUpIHtcclxuICAgIHZhciBwbHVnaW5SZWYsIHBsdWdpbkluc3RhbmNlLCBwbHVnaW5QYWNrYWdlO1xyXG4gICAgaWYgKHR5cGVvZiBwbHVnaW4gPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgcGx1Z2luUmVmID0gcGx1Z2luO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcGx1Z2luUmVmID0gcGx1Z2luLmNvbnN0cnVjdG9yLmdldFBsdWdpblJlZigpO1xyXG4gICAgICAgIHBsdWdpbk5hbWUgPSBwbHVnaW4uY29uc3RydWN0b3IuZ2V0UGx1Z2luTmFtZSgpO1xyXG4gICAgICAgIHBsdWdpblBhY2thZ2UgPSBwbHVnaW4uY29uc3RydWN0b3IuZ2V0UGx1Z2luSW5zdGFsbE5hbWUoKTtcclxuICAgIH1cclxuICAgIHBsdWdpbkluc3RhbmNlID0gZ2V0UGx1Z2luKHBsdWdpblJlZik7XHJcbiAgICBpZiAoIXBsdWdpbkluc3RhbmNlIHx8ICghIW1ldGhvZE5hbWUgJiYgdHlwZW9mIHBsdWdpbkluc3RhbmNlW21ldGhvZE5hbWVdID09PSAndW5kZWZpbmVkJykpIHtcclxuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgfHwgIXdpbmRvdy5jb3Jkb3ZhKSB7XHJcbiAgICAgICAgICAgIGNvcmRvdmFXYXJuKHBsdWdpbk5hbWUsIG1ldGhvZE5hbWUpO1xyXG4gICAgICAgICAgICByZXR1cm4gRVJSX0NPUkRPVkFfTk9UX0FWQUlMQUJMRTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcGx1Z2luV2FybihwbHVnaW5OYW1lLCBwbHVnaW5QYWNrYWdlLCBtZXRob2ROYW1lKTtcclxuICAgICAgICByZXR1cm4gRVJSX1BMVUdJTl9OT1RfSU5TVEFMTEVEO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuLyoqXHJcbiAqIENoZWNrcyBpZiBfb2JqZWN0SW5zdGFuY2UgZXhpc3RzIGFuZCBoYXMgdGhlIG1ldGhvZC9wcm9wZXJ0eVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gaW5zdGFuY2VBdmFpbGFiaWxpdHkocGx1Z2luT2JqLCBtZXRob2ROYW1lKSB7XHJcbiAgICByZXR1cm4gcGx1Z2luT2JqLl9vYmplY3RJbnN0YW5jZSAmJiAoIW1ldGhvZE5hbWUgfHwgdHlwZW9mIHBsdWdpbk9iai5fb2JqZWN0SW5zdGFuY2VbbWV0aG9kTmFtZV0gIT09ICd1bmRlZmluZWQnKTtcclxufVxyXG5mdW5jdGlvbiBzZXRJbmRleChhcmdzLCBvcHRzLCByZXNvbHZlLCByZWplY3QpIHtcclxuICAgIGlmIChvcHRzID09PSB2b2lkIDApIHsgb3B0cyA9IHt9OyB9XHJcbiAgICAvLyBpZ25vcmUgcmVzb2x2ZSBhbmQgcmVqZWN0IGluIGNhc2Ugc3luY1xyXG4gICAgaWYgKG9wdHMuc3luYykge1xyXG4gICAgICAgIHJldHVybiBhcmdzO1xyXG4gICAgfVxyXG4gICAgLy8gSWYgdGhlIHBsdWdpbiBtZXRob2QgZXhwZWN0cyBteU1ldGhvZChzdWNjZXNzLCBlcnIsIG9wdGlvbnMpXHJcbiAgICBpZiAob3B0cy5jYWxsYmFja09yZGVyID09PSAncmV2ZXJzZScpIHtcclxuICAgICAgICAvLyBHZXQgdGhvc2UgYXJndW1lbnRzIGluIHRoZSBvcmRlciBbcmVzb2x2ZSwgcmVqZWN0LCAuLi5yZXN0T2ZBcmdzXVxyXG4gICAgICAgIGFyZ3MudW5zaGlmdChyZWplY3QpO1xyXG4gICAgICAgIGFyZ3MudW5zaGlmdChyZXNvbHZlKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKG9wdHMuY2FsbGJhY2tTdHlsZSA9PT0gJ25vZGUnKSB7XHJcbiAgICAgICAgYXJncy5wdXNoKGZ1bmN0aW9uIChlcnIsIHJlc3VsdCkge1xyXG4gICAgICAgICAgICBpZiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAob3B0cy5jYWxsYmFja1N0eWxlID09PSAnb2JqZWN0JyAmJiBvcHRzLnN1Y2Nlc3NOYW1lICYmIG9wdHMuZXJyb3JOYW1lKSB7XHJcbiAgICAgICAgdmFyIG9iaiA9IHt9O1xyXG4gICAgICAgIG9ialtvcHRzLnN1Y2Nlc3NOYW1lXSA9IHJlc29sdmU7XHJcbiAgICAgICAgb2JqW29wdHMuZXJyb3JOYW1lXSA9IHJlamVjdDtcclxuICAgICAgICBhcmdzLnB1c2gob2JqKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGVvZiBvcHRzLnN1Y2Nlc3NJbmRleCAhPT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIG9wdHMuZXJyb3JJbmRleCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICB2YXIgc2V0U3VjY2Vzc0luZGV4ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAvLyBJZiB3ZSd2ZSBzcGVjaWZpZWQgYSBzdWNjZXNzL2Vycm9yIGluZGV4XHJcbiAgICAgICAgICAgIGlmIChvcHRzLnN1Y2Nlc3NJbmRleCA+IGFyZ3MubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBhcmdzW29wdHMuc3VjY2Vzc0luZGV4XSA9IHJlc29sdmU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBhcmdzLnNwbGljZShvcHRzLnN1Y2Nlc3NJbmRleCwgMCwgcmVzb2x2ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhciBzZXRFcnJvckluZGV4ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAvLyBXZSBkb24ndCB3YW50IHRoYXQgdGhlIHJlamVjdCBjYiBnZXRzIHNwbGljZWQgaW50byB0aGUgcG9zaXRpb24gb2YgYW4gb3B0aW9uYWwgYXJndW1lbnQgdGhhdCBoYXMgbm90IGJlZW5cclxuICAgICAgICAgICAgLy8gZGVmaW5lZCBhbmQgdGh1cyBjYXVzaW5nIG5vbiBleHBlY3RlZCBiZWhhdmlvci5cclxuICAgICAgICAgICAgaWYgKG9wdHMuZXJyb3JJbmRleCA+IGFyZ3MubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBhcmdzW29wdHMuZXJyb3JJbmRleF0gPSByZWplY3Q7IC8vIGluc2VydCB0aGUgcmVqZWN0IGZuIGF0IHRoZSBjb3JyZWN0IHNwZWNpZmljIGluZGV4XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBhcmdzLnNwbGljZShvcHRzLmVycm9ySW5kZXgsIDAsIHJlamVjdCk7IC8vIG90aGVyd2lzZSBqdXN0IHNwbGljZSBpdCBpbnRvIHRoZSBhcnJheVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAob3B0cy5zdWNjZXNzSW5kZXggPiBvcHRzLmVycm9ySW5kZXgpIHtcclxuICAgICAgICAgICAgc2V0RXJyb3JJbmRleCgpO1xyXG4gICAgICAgICAgICBzZXRTdWNjZXNzSW5kZXgoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHNldFN1Y2Nlc3NJbmRleCgpO1xyXG4gICAgICAgICAgICBzZXRFcnJvckluZGV4KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBsZXQncyB0YWNrIHRoZW0gb24gdG8gdGhlIGVuZCBvZiB0aGUgYXJndW1lbnQgbGlzdFxyXG4gICAgICAgIC8vIHdoaWNoIGlzIDkwJSBvZiBjYXNlc1xyXG4gICAgICAgIGFyZ3MucHVzaChyZXNvbHZlKTtcclxuICAgICAgICBhcmdzLnB1c2gocmVqZWN0KTtcclxuICAgIH1cclxuICAgIHJldHVybiBhcmdzO1xyXG59XHJcbmZ1bmN0aW9uIGNhbGxDb3Jkb3ZhUGx1Z2luKHBsdWdpbk9iaiwgbWV0aG9kTmFtZSwgYXJncywgb3B0cywgcmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICBpZiAob3B0cyA9PT0gdm9pZCAwKSB7IG9wdHMgPSB7fTsgfVxyXG4gICAgLy8gVHJ5IHRvIGZpZ3VyZSBvdXQgd2hlcmUgdGhlIHN1Y2Nlc3MvZXJyb3IgY2FsbGJhY2tzIG5lZWQgdG8gYmUgYm91bmRcclxuICAgIC8vIHRvIG91ciBwcm9taXNlIHJlc29sdmUvcmVqZWN0IGhhbmRsZXJzLlxyXG4gICAgYXJncyA9IHNldEluZGV4KGFyZ3MsIG9wdHMsIHJlc29sdmUsIHJlamVjdCk7XHJcbiAgICB2YXIgYXZhaWxhYmlsaXR5Q2hlY2sgPSBjaGVja0F2YWlsYWJpbGl0eShwbHVnaW5PYmosIG1ldGhvZE5hbWUpO1xyXG4gICAgaWYgKGF2YWlsYWJpbGl0eUNoZWNrID09PSB0cnVlKSB7XHJcbiAgICAgICAgdmFyIHBsdWdpbkluc3RhbmNlID0gZ2V0UGx1Z2luKHBsdWdpbk9iai5jb25zdHJ1Y3Rvci5nZXRQbHVnaW5SZWYoKSk7XHJcbiAgICAgICAgcmV0dXJuIHBsdWdpbkluc3RhbmNlW21ldGhvZE5hbWVdLmFwcGx5KHBsdWdpbkluc3RhbmNlLCBhcmdzKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBhdmFpbGFiaWxpdHlDaGVjaztcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBjYWxsSW5zdGFuY2UocGx1Z2luT2JqLCBtZXRob2ROYW1lLCBhcmdzLCBvcHRzLCByZXNvbHZlLCByZWplY3QpIHtcclxuICAgIGlmIChvcHRzID09PSB2b2lkIDApIHsgb3B0cyA9IHt9OyB9XHJcbiAgICBhcmdzID0gc2V0SW5kZXgoYXJncywgb3B0cywgcmVzb2x2ZSwgcmVqZWN0KTtcclxuICAgIGlmIChpbnN0YW5jZUF2YWlsYWJpbGl0eShwbHVnaW5PYmosIG1ldGhvZE5hbWUpKSB7XHJcbiAgICAgICAgcmV0dXJuIHBsdWdpbk9iai5fb2JqZWN0SW5zdGFuY2VbbWV0aG9kTmFtZV0uYXBwbHkocGx1Z2luT2JqLl9vYmplY3RJbnN0YW5jZSwgYXJncyk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZ2V0UGx1Z2luKHBsdWdpblJlZikge1xyXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgcmV0dXJuIGdldCQxKHdpbmRvdywgcGx1Z2luUmVmKTtcclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG59XHJcbmZ1bmN0aW9uIGdldCQxKGVsZW1lbnQsIHBhdGgpIHtcclxuICAgIHZhciBwYXRocyA9IHBhdGguc3BsaXQoJy4nKTtcclxuICAgIHZhciBvYmogPSBlbGVtZW50O1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRocy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlmICghb2JqKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBvYmogPSBvYmpbcGF0aHNbaV1dO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG9iajtcclxufVxyXG5mdW5jdGlvbiBwbHVnaW5XYXJuKHBsdWdpbk5hbWUsIHBsdWdpbiwgbWV0aG9kKSB7XHJcbiAgICBpZiAobWV0aG9kKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKCdOYXRpdmU6IHRyaWVkIGNhbGxpbmcgJyArIHBsdWdpbk5hbWUgKyAnLicgKyBtZXRob2QgKyAnLCBidXQgdGhlICcgKyBwbHVnaW5OYW1lICsgJyBwbHVnaW4gaXMgbm90IGluc3RhbGxlZC4nKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGNvbnNvbGUud2FybihcIk5hdGl2ZTogdHJpZWQgYWNjZXNzaW5nIHRoZSBcIiArIHBsdWdpbk5hbWUgKyBcIiBwbHVnaW4gYnV0IGl0J3Mgbm90IGluc3RhbGxlZC5cIik7XHJcbiAgICB9XHJcbiAgICBpZiAocGx1Z2luKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKFwiSW5zdGFsbCB0aGUgXCIgKyBwbHVnaW5OYW1lICsgXCIgcGx1Z2luOiAnaW9uaWMgY29yZG92YSBwbHVnaW4gYWRkIFwiICsgcGx1Z2luICsgXCInXCIpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0gcGx1Z2luTmFtZVxyXG4gKiBAcGFyYW0gbWV0aG9kXHJcbiAqL1xyXG5mdW5jdGlvbiBjb3Jkb3ZhV2FybihwbHVnaW5OYW1lLCBtZXRob2QpIHtcclxuICAgIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICBpZiAobWV0aG9kKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignTmF0aXZlOiB0cmllZCBjYWxsaW5nICcgK1xyXG4gICAgICAgICAgICAgICAgcGx1Z2luTmFtZSArXHJcbiAgICAgICAgICAgICAgICAnLicgK1xyXG4gICAgICAgICAgICAgICAgbWV0aG9kICtcclxuICAgICAgICAgICAgICAgICcsIGJ1dCBDb3Jkb3ZhIGlzIG5vdCBhdmFpbGFibGUuIE1ha2Ugc3VyZSB0byBpbmNsdWRlIGNvcmRvdmEuanMgb3IgcnVuIGluIGEgZGV2aWNlL3NpbXVsYXRvcicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKCdOYXRpdmU6IHRyaWVkIGFjY2Vzc2luZyB0aGUgJyArXHJcbiAgICAgICAgICAgICAgICBwbHVnaW5OYW1lICtcclxuICAgICAgICAgICAgICAgICcgcGx1Z2luIGJ1dCBDb3Jkb3ZhIGlzIG5vdCBhdmFpbGFibGUuIE1ha2Ugc3VyZSB0byBpbmNsdWRlIGNvcmRvdmEuanMgb3IgcnVuIGluIGEgZGV2aWNlL3NpbXVsYXRvcicpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKipcclxuICogQHByaXZhdGVcclxuICovXHJcbnZhciB3cmFwID0gZnVuY3Rpb24gKHBsdWdpbk9iaiwgbWV0aG9kTmFtZSwgb3B0cykge1xyXG4gICAgaWYgKG9wdHMgPT09IHZvaWQgMCkgeyBvcHRzID0ge307IH1cclxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvcHRzLnN5bmMpIHtcclxuICAgICAgICAgICAgLy8gU3luYyBkb2Vzbid0IHdyYXAgdGhlIHBsdWdpbiB3aXRoIGEgcHJvbWlzZSBvciBvYnNlcnZhYmxlLCBpdCByZXR1cm5zIHRoZSByZXN1bHQgYXMtaXNcclxuICAgICAgICAgICAgcmV0dXJuIGNhbGxDb3Jkb3ZhUGx1Z2luKHBsdWdpbk9iaiwgbWV0aG9kTmFtZSwgYXJncywgb3B0cyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG9wdHMub2JzZXJ2YWJsZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gd3JhcE9ic2VydmFibGUocGx1Z2luT2JqLCBtZXRob2ROYW1lLCBhcmdzLCBvcHRzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAob3B0cy5ldmVudE9ic2VydmFibGUgJiYgb3B0cy5ldmVudCkge1xyXG4gICAgICAgICAgICByZXR1cm4gd3JhcEV2ZW50T2JzZXJ2YWJsZShvcHRzLmV2ZW50LCBvcHRzLmVsZW1lbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChvcHRzLm90aGVyUHJvbWlzZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gd3JhcE90aGVyUHJvbWlzZShwbHVnaW5PYmosIG1ldGhvZE5hbWUsIGFyZ3MsIG9wdHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHdyYXBQcm9taXNlKHBsdWdpbk9iaiwgbWV0aG9kTmFtZSwgYXJncywgb3B0cyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufTtcclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiB3cmFwSW5zdGFuY2UocGx1Z2luT2JqLCBtZXRob2ROYW1lLCBvcHRzKSB7XHJcbiAgICBpZiAob3B0cyA9PT0gdm9pZCAwKSB7IG9wdHMgPSB7fTsgfVxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9wdHMuc3luYykge1xyXG4gICAgICAgICAgICByZXR1cm4gY2FsbEluc3RhbmNlKHBsdWdpbk9iaiwgbWV0aG9kTmFtZSwgYXJncywgb3B0cyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG9wdHMub2JzZXJ2YWJsZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IHJ4anMuT2JzZXJ2YWJsZShmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcclxuICAgICAgICAgICAgICAgIHZhciBwbHVnaW5SZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICBpZiAob3B0cy5kZXN0cnVjdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBsdWdpblJlc3VsdCA9IGNhbGxJbnN0YW5jZShwbHVnaW5PYmosIG1ldGhvZE5hbWUsIGFyZ3MsIG9wdHMsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2JzZXJ2ZXIubmV4dChhcmdzKTtcclxuICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhcmdzID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9ic2VydmVyLmVycm9yKGFyZ3MpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGx1Z2luUmVzdWx0ID0gY2FsbEluc3RhbmNlKHBsdWdpbk9iaiwgbWV0aG9kTmFtZSwgYXJncywgb3B0cywgb2JzZXJ2ZXIubmV4dC5iaW5kKG9ic2VydmVyKSwgb2JzZXJ2ZXIuZXJyb3IuYmluZChvYnNlcnZlcikpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHBsdWdpblJlc3VsdCAmJiBwbHVnaW5SZXN1bHQuZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5lcnJvcihwbHVnaW5SZXN1bHQuZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0cy5jbGVhcldpdGhBcmdzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbEluc3RhbmNlKHBsdWdpbk9iaiwgb3B0cy5jbGVhckZ1bmN0aW9uLCBhcmdzLCBvcHRzLCBvYnNlcnZlci5uZXh0LmJpbmQob2JzZXJ2ZXIpLCBvYnNlcnZlci5lcnJvci5iaW5kKG9ic2VydmVyKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxJbnN0YW5jZShwbHVnaW5PYmosIG9wdHMuY2xlYXJGdW5jdGlvbiwgW10pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1VuYWJsZSB0byBjbGVhciB0aGUgcHJldmlvdXMgb2JzZXJ2YWJsZSB3YXRjaCBmb3InLCBwbHVnaW5PYmouY29uc3RydWN0b3IuZ2V0UGx1Z2luTmFtZSgpLCBtZXRob2ROYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChvcHRzLm90aGVyUHJvbWlzZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZ2V0UHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgaWYgKG9wdHMuZGVzdHJ1Y3QpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBjYWxsSW5zdGFuY2UocGx1Z2luT2JqLCBtZXRob2ROYW1lLCBhcmdzLCBvcHRzLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhcmdzID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoYXJncyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoYXJncyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBjYWxsSW5zdGFuY2UocGx1Z2luT2JqLCBtZXRob2ROYW1lLCBhcmdzLCBvcHRzLCByZXNvbHZlLCByZWplY3QpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCAmJiByZXN1bHQudGhlbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC50aGVuKHJlc29sdmUsIHJlamVjdCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZWplY3QoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgcGx1Z2luUmVzdWx0XzEsIHJlal8xO1xyXG4gICAgICAgICAgICB2YXIgcCA9IGdldFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG9wdHMuZGVzdHJ1Y3QpIHtcclxuICAgICAgICAgICAgICAgICAgICBwbHVnaW5SZXN1bHRfMSA9IGNhbGxJbnN0YW5jZShwbHVnaW5PYmosIG1ldGhvZE5hbWUsIGFyZ3MsIG9wdHMsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShhcmdzKTtcclxuICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhcmdzID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChhcmdzKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHBsdWdpblJlc3VsdF8xID0gY2FsbEluc3RhbmNlKHBsdWdpbk9iaiwgbWV0aG9kTmFtZSwgYXJncywgb3B0cywgcmVzb2x2ZSwgcmVqZWN0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJlal8xID0gcmVqZWN0O1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgLy8gQW5ndWxhciB0aHJvd3MgYW4gZXJyb3Igb24gdW5oYW5kbGVkIHJlamVjdGlvbiwgYnV0IGluIHRoaXMgY2FzZSB3ZSBoYXZlIGFscmVhZHkgcHJpbnRlZFxyXG4gICAgICAgICAgICAvLyBhIHdhcm5pbmcgdGhhdCBDb3Jkb3ZhIGlzIHVuZGVmaW5lZCBvciB0aGUgcGx1Z2luIGlzIHVuaW5zdGFsbGVkLCBzbyB0aGVyZSBpcyBubyByZWFzb25cclxuICAgICAgICAgICAgLy8gdG8gZXJyb3JcclxuICAgICAgICAgICAgaWYgKHBsdWdpblJlc3VsdF8xICYmIHBsdWdpblJlc3VsdF8xLmVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICBwLmNhdGNoKGZ1bmN0aW9uICgpIHsgfSk7XHJcbiAgICAgICAgICAgICAgICB0eXBlb2YgcmVqXzEgPT09ICdmdW5jdGlvbicgJiYgcmVqXzEocGx1Z2luUmVzdWx0XzEuZXJyb3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBwO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0KGVsZW1lbnQsIHBhdGgpIHtcclxuICAgIHZhciBwYXRocyA9IHBhdGguc3BsaXQoJy4nKTtcclxuICAgIHZhciBvYmogPSBlbGVtZW50O1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRocy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlmICghb2JqKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBvYmogPSBvYmpbcGF0aHNbaV1dO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG9iajtcclxufVxyXG5cclxudmFyIElvbmljTmF0aXZlUGx1Z2luID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gSW9uaWNOYXRpdmVQbHVnaW4oKSB7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBib29sZWFuIHRoYXQgaW5kaWNhdGVzIHdoZXRoZXIgdGhlIHBsdWdpbiBpcyBpbnN0YWxsZWRcclxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIElvbmljTmF0aXZlUGx1Z2luLmluc3RhbGxlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgaXNBdmFpbGFibGUgPSBjaGVja0F2YWlsYWJpbGl0eSh0aGlzLnBsdWdpblJlZikgPT09IHRydWU7XHJcbiAgICAgICAgcmV0dXJuIGlzQXZhaWxhYmxlO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgb3JpZ2luYWwgcGx1Z2luIG9iamVjdFxyXG4gICAgICovXHJcbiAgICBJb25pY05hdGl2ZVBsdWdpbi5nZXRQbHVnaW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBnZXQod2luZG93LCB0aGlzLnBsdWdpblJlZik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgcGx1Z2luJ3MgbmFtZVxyXG4gICAgICovXHJcbiAgICBJb25pY05hdGl2ZVBsdWdpbi5nZXRQbHVnaW5OYW1lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBwbHVnaW5OYW1lID0gdGhpcy5wbHVnaW5OYW1lO1xyXG4gICAgICAgIHJldHVybiBwbHVnaW5OYW1lO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgcGx1Z2luJ3MgcmVmZXJlbmNlXHJcbiAgICAgKi9cclxuICAgIElvbmljTmF0aXZlUGx1Z2luLmdldFBsdWdpblJlZiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgcGx1Z2luUmVmID0gdGhpcy5wbHVnaW5SZWY7XHJcbiAgICAgICAgcmV0dXJuIHBsdWdpblJlZjtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHBsdWdpbidzIGluc3RhbGwgbmFtZVxyXG4gICAgICovXHJcbiAgICBJb25pY05hdGl2ZVBsdWdpbi5nZXRQbHVnaW5JbnN0YWxsTmFtZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgcGx1Z2luID0gdGhpcy5wbHVnaW47XHJcbiAgICAgICAgcmV0dXJuIHBsdWdpbjtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHBsdWdpbidzIHN1cHBvcnRlZCBwbGF0Zm9ybXNcclxuICAgICAqL1xyXG4gICAgSW9uaWNOYXRpdmVQbHVnaW4uZ2V0U3VwcG9ydGVkUGxhdGZvcm1zID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBwbGF0Zm9ybSA9IHRoaXMucGxhdGZvcm1zO1xyXG4gICAgICAgIHJldHVybiBwbGF0Zm9ybTtcclxuICAgIH07XHJcbiAgICBJb25pY05hdGl2ZVBsdWdpbi5wbHVnaW5OYW1lID0gJyc7XHJcbiAgICBJb25pY05hdGl2ZVBsdWdpbi5wbHVnaW5SZWYgPSAnJztcclxuICAgIElvbmljTmF0aXZlUGx1Z2luLnBsdWdpbiA9ICcnO1xyXG4gICAgSW9uaWNOYXRpdmVQbHVnaW4ucmVwbyA9ICcnO1xyXG4gICAgSW9uaWNOYXRpdmVQbHVnaW4ucGxhdGZvcm1zID0gW107XHJcbiAgICBJb25pY05hdGl2ZVBsdWdpbi5pbnN0YWxsID0gJyc7XHJcbiAgICByZXR1cm4gSW9uaWNOYXRpdmVQbHVnaW47XHJcbn0oKSk7XHJcblxyXG5mdW5jdGlvbiBjb3Jkb3ZhKHBsdWdpbk9iaiwgbWV0aG9kTmFtZSwgY29uZmlnLCBhcmdzKSB7XHJcbiAgICByZXR1cm4gd3JhcChwbHVnaW5PYmosIG1ldGhvZE5hbWUsIGNvbmZpZykuYXBwbHkodGhpcywgYXJncyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG92ZXJyaWRlRnVuY3Rpb24ocGx1Z2luT2JqLCBtZXRob2ROYW1lKSB7XHJcbiAgICByZXR1cm4gbmV3IHJ4anMuT2JzZXJ2YWJsZShmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcclxuICAgICAgICB2YXIgYXZhaWxhYmlsaXR5Q2hlY2sgPSBjaGVja0F2YWlsYWJpbGl0eShwbHVnaW5PYmosIG1ldGhvZE5hbWUpO1xyXG4gICAgICAgIGlmIChhdmFpbGFiaWxpdHlDaGVjayA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICB2YXIgcGx1Z2luSW5zdGFuY2VfMSA9IGdldFBsdWdpbihwbHVnaW5PYmouY29uc3RydWN0b3IuZ2V0UGx1Z2luUmVmKCkpO1xyXG4gICAgICAgICAgICBwbHVnaW5JbnN0YW5jZV8xW21ldGhvZE5hbWVdID0gb2JzZXJ2ZXIubmV4dC5iaW5kKG9ic2VydmVyKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIChwbHVnaW5JbnN0YW5jZV8xW21ldGhvZE5hbWVdID0gZnVuY3Rpb24gKCkgeyB9KTsgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG9ic2VydmVyLmVycm9yKGF2YWlsYWJpbGl0eUNoZWNrKTtcclxuICAgICAgICAgICAgb2JzZXJ2ZXIuY29tcGxldGUoKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBjb3Jkb3ZhRnVuY3Rpb25PdmVycmlkZShwbHVnaW5PYmosIG1ldGhvZE5hbWUsIGFyZ3MpIHtcclxuICAgIHJldHVybiBvdmVycmlkZUZ1bmN0aW9uKHBsdWdpbk9iaiwgbWV0aG9kTmFtZSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNvcmRvdmFJbnN0YW5jZShwbHVnaW5PYmosIG1ldGhvZE5hbWUsIGNvbmZpZywgYXJncykge1xyXG4gICAgYXJncyA9IEFycmF5LmZyb20oYXJncyk7XHJcbiAgICByZXR1cm4gd3JhcEluc3RhbmNlKHBsdWdpbk9iaiwgbWV0aG9kTmFtZSwgY29uZmlnKS5hcHBseSh0aGlzLCBhcmdzKTtcclxufVxyXG5cclxuZnVuY3Rpb24gY29yZG92YVByb3BlcnR5R2V0KHBsdWdpbk9iaiwga2V5KSB7XHJcbiAgICBpZiAoY2hlY2tBdmFpbGFiaWxpdHkocGx1Z2luT2JqLCBrZXkpID09PSB0cnVlKSB7XHJcbiAgICAgICAgcmV0dXJuIGdldFBsdWdpbihwbHVnaW5PYmouY29uc3RydWN0b3IuZ2V0UGx1Z2luUmVmKCkpW2tleV07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxufVxyXG5mdW5jdGlvbiBjb3Jkb3ZhUHJvcGVydHlTZXQocGx1Z2luT2JqLCBrZXksIHZhbHVlKSB7XHJcbiAgICBpZiAoY2hlY2tBdmFpbGFiaWxpdHkocGx1Z2luT2JqLCBrZXkpID09PSB0cnVlKSB7XHJcbiAgICAgICAgZ2V0UGx1Z2luKHBsdWdpbk9iai5jb25zdHJ1Y3Rvci5nZXRQbHVnaW5SZWYoKSlba2V5XSA9IHZhbHVlO1xyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBpbnN0YW5jZVByb3BlcnR5R2V0KHBsdWdpbk9iaiwga2V5KSB7XHJcbiAgICBpZiAocGx1Z2luT2JqLl9vYmplY3RJbnN0YW5jZSAmJiBwbHVnaW5PYmouX29iamVjdEluc3RhbmNlW2tleV0pIHtcclxuICAgICAgICByZXR1cm4gcGx1Z2luT2JqLl9vYmplY3RJbnN0YW5jZVtrZXldO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn1cclxuZnVuY3Rpb24gaW5zdGFuY2VQcm9wZXJ0eVNldChwbHVnaW5PYmosIGtleSwgdmFsdWUpIHtcclxuICAgIGlmIChwbHVnaW5PYmouX29iamVjdEluc3RhbmNlKSB7XHJcbiAgICAgICAgcGx1Z2luT2JqLl9vYmplY3RJbnN0YW5jZVtrZXldID0gdmFsdWU7XHJcbiAgICB9XHJcbn1cclxuXHJcbmNoZWNrUmVhZHkoKTtcclxuXHJcbmV4cG9ydHMuSW9uaWNOYXRpdmVQbHVnaW4gPSBJb25pY05hdGl2ZVBsdWdpbjtcclxuZXhwb3J0cy5jaGVja0F2YWlsYWJpbGl0eSA9IGNoZWNrQXZhaWxhYmlsaXR5O1xyXG5leHBvcnRzLmNvcmRvdmEgPSBjb3Jkb3ZhO1xyXG5leHBvcnRzLmNvcmRvdmFGdW5jdGlvbk92ZXJyaWRlID0gY29yZG92YUZ1bmN0aW9uT3ZlcnJpZGU7XHJcbmV4cG9ydHMuY29yZG92YUluc3RhbmNlID0gY29yZG92YUluc3RhbmNlO1xyXG5leHBvcnRzLmNvcmRvdmFQcm9wZXJ0eUdldCA9IGNvcmRvdmFQcm9wZXJ0eUdldDtcclxuZXhwb3J0cy5jb3Jkb3ZhUHJvcGVydHlTZXQgPSBjb3Jkb3ZhUHJvcGVydHlTZXQ7XHJcbmV4cG9ydHMuZ2V0UHJvbWlzZSA9IGdldFByb21pc2U7XHJcbmV4cG9ydHMuaW5zdGFuY2VBdmFpbGFiaWxpdHkgPSBpbnN0YW5jZUF2YWlsYWJpbGl0eTtcclxuZXhwb3J0cy5pbnN0YW5jZVByb3BlcnR5R2V0ID0gaW5zdGFuY2VQcm9wZXJ0eUdldDtcclxuZXhwb3J0cy5pbnN0YW5jZVByb3BlcnR5U2V0ID0gaW5zdGFuY2VQcm9wZXJ0eVNldDtcclxuZXhwb3J0cy53cmFwID0gd3JhcDtcclxuIl19