import * as tslib_1 from "tslib";
import { Injectable } from '@angular/core';
import { createAnimation, getTimeGivenProgression } from '@ionic/core';
import * as i0 from "@angular/core";
import * as ɵngcc0 from '@angular/core';
let AnimationController = class AnimationController {
    /**
     * Create a new animation
     */
    create(animationId) {
        return createAnimation(animationId);
    }
    /**
     * EXPERIMENTAL
     *
     * Given a progression and a cubic bezier function,
     * this utility returns the time value(s) at which the
     * cubic bezier reaches the given time progression.
     *
     * If the cubic bezier never reaches the progression
     * the result will be an empty array.
     *
     * This is most useful for switching between easing curves
     * when doing a gesture animation (i.e. going from linear easing
     * during a drag, to another easing when `progressEnd` is called)
     */
    easingTime(p0, p1, p2, p3, progression) {
        return getTimeGivenProgression(p0, p1, p2, p3, progression);
    }
};
AnimationController.ɵfac = function AnimationController_Factory(t) { return new (t || AnimationController)(); };
AnimationController.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: AnimationController, factory: AnimationController.ɵfac, providedIn: 'root' });
AnimationController.ngInjectableDef = i0.ɵɵdefineInjectable({ factory: function AnimationController_Factory() { return new AnimationController(); }, token: AnimationController, providedIn: "root" });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(AnimationController, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], null, null); })();
export { AnimationController };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYW5pbWF0aW9uLWNvbnRyb2xsZXIuanMiLCJzb3VyY2VzIjpbIm5nOi9AaW9uaWMvYW5ndWxhci9wcm92aWRlcnMvYW5pbWF0aW9uLWNvbnRyb2xsZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDM0MsT0FBTyxFQUFhLGVBQWUsRUFBRSx1QkFBdUIsRUFBRSxNQUFNLGFBQWEsQ0FBQztBQUNsRjs7QUFJQSxJQUFhLG1CQUFtQixHQUFoQyxNQUFhLG1CQUFtQjtBQUNoQyxJQUFFO0FBQ0Y7QUFDRSxPQUFHO0FBQ0wsSUFBRSxNQUFNLENBQUMsV0FBb0I7QUFBSSxRQUM3QixPQUFPLGVBQWUsQ0FBQyxXQUFXLENBQUMsQ0FBQztBQUN4QyxJQUFFLENBQUM7QUFDSCxJQUNFO0FBQ0Y7QUFDRTtBQUNFO0FBQ0U7QUFDRTtBQUVIO0FBQU87QUFDRTtBQUVIO0FBQU87QUFDRTtBQUNFO0FBRUosT0FEYjtBQUNMLElBQUUsVUFBVSxDQUFDLEVBQVksRUFBRSxFQUFZLEVBQUUsRUFBWSxFQUFFLEVBQVksRUFBRSxXQUFtQjtBQUFJLFFBQ3hGLE9BQU8sdUJBQXVCLENBQUMsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLFdBQVcsQ0FBQyxDQUFDO0FBQ2hFLElBQUUsQ0FBQztBQUNILENBQUM7OzZJQUFBO0FBQ0Q7QUExQmEsbUJBQW1CLDRCQUgvQixVQUFVLENBQUMsVUFDVjtBQUFVLEVBQUUsTUFBTSxPQUNuQixDQUFDLElBQ1c7YUFBbUIsQ0F5Qi9COzs7MEJBQ0Q7O0FBaENBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFDQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUtBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBRUEsQUFDQSxBQUFBLEFBQUEsQUFBQSxBQUNBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQ0EsQUFBQSxBQUVBLEFBYUEsQUFDQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFDQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFBQSxBQUFBLEFBQUEsQUFDQSxBQUFBLEFBQ0EsQUFBQSxBQXpCQSxBQUFBLEFBSEEsQUFBQSxBQUFBLEFBQ0EsQUFBQSxBQUFBLEFBQUEsQUFDQSxBQUFBLEFBQ0EsQUFBQSxBQXlCQSxBQXpCQSxBQUFBIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQW5pbWF0aW9uLCBjcmVhdGVBbmltYXRpb24sIGdldFRpbWVHaXZlblByb2dyZXNzaW9uIH0gZnJvbSAnQGlvbmljL2NvcmUnO1xuXG5ASW5qZWN0YWJsZSh7XG4gIHByb3ZpZGVkSW46ICdyb290Jyxcbn0pXG5leHBvcnQgY2xhc3MgQW5pbWF0aW9uQ29udHJvbGxlciB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgYW5pbWF0aW9uXG4gICAqL1xuICBjcmVhdGUoYW5pbWF0aW9uSWQ/OiBzdHJpbmcpOiBBbmltYXRpb24ge1xuICAgIHJldHVybiBjcmVhdGVBbmltYXRpb24oYW5pbWF0aW9uSWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEVYUEVSSU1FTlRBTFxuICAgKlxuICAgKiBHaXZlbiBhIHByb2dyZXNzaW9uIGFuZCBhIGN1YmljIGJlemllciBmdW5jdGlvbixcbiAgICogdGhpcyB1dGlsaXR5IHJldHVybnMgdGhlIHRpbWUgdmFsdWUocykgYXQgd2hpY2ggdGhlXG4gICAqIGN1YmljIGJlemllciByZWFjaGVzIHRoZSBnaXZlbiB0aW1lIHByb2dyZXNzaW9uLlxuICAgKlxuICAgKiBJZiB0aGUgY3ViaWMgYmV6aWVyIG5ldmVyIHJlYWNoZXMgdGhlIHByb2dyZXNzaW9uXG4gICAqIHRoZSByZXN1bHQgd2lsbCBiZSBhbiBlbXB0eSBhcnJheS5cbiAgICpcbiAgICogVGhpcyBpcyBtb3N0IHVzZWZ1bCBmb3Igc3dpdGNoaW5nIGJldHdlZW4gZWFzaW5nIGN1cnZlc1xuICAgKiB3aGVuIGRvaW5nIGEgZ2VzdHVyZSBhbmltYXRpb24gKGkuZS4gZ29pbmcgZnJvbSBsaW5lYXIgZWFzaW5nXG4gICAqIGR1cmluZyBhIGRyYWcsIHRvIGFub3RoZXIgZWFzaW5nIHdoZW4gYHByb2dyZXNzRW5kYCBpcyBjYWxsZWQpXG4gICAqL1xuICBlYXNpbmdUaW1lKHAwOiBudW1iZXJbXSwgcDE6IG51bWJlcltdLCBwMjogbnVtYmVyW10sIHAzOiBudW1iZXJbXSwgcHJvZ3Jlc3Npb246IG51bWJlcik6IG51bWJlcltdIHtcbiAgICByZXR1cm4gZ2V0VGltZUdpdmVuUHJvZ3Jlc3Npb24ocDAsIHAxLCBwMiwgcDMsIHByb2dyZXNzaW9uKTtcbiAgfVxufVxuIl19